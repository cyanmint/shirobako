/**
 * This file contains content generated by AI.
 * AI-generated contents are not applicable for copyright nor warranty.
 */
package top.niunaijun.blackbox.core;

import android.content.Context;
import android.os.Build;
import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * QEMU User Mode Emulation Manager
 * Manages cross-architecture execution using QEMU user mode emulation
 * 
 * Architecture support matrix:
 * - Host arm64+arm32: use QEMU for x86_64
 * - Host arm64 only: use QEMU for arm32 & x86_64
 * - Host x86_64 only: use QEMU for arm64 & arm32
 */
public class QemuManager {
    private static final String TAG = "QemuManager";
    
    // Supported architectures (x86/i386 removed per redroid limitation)
    private static final String ABI_ARM64 = "arm64-v8a";
    private static final String ABI_ARM32 = "armeabi-v7a";
    private static final String ABI_X86_64 = "x86_64";
    
    private static QemuManager instance;
    private Context context;
    private Set<String> nativeSupportedAbis;
    private File qemuBaseDir;
    private File runtimeBaseDir;
    private boolean initialized = false;
    
    private QemuManager() {
        nativeSupportedAbis = new HashSet<>();
    }
    
    public static synchronized QemuManager getInstance() {
        if (instance == null) {
            instance = new QemuManager();
        }
        return instance;
    }
    
    /**
     * Initialize QEMU manager with application context
     */
    public synchronized void init(Context context) {
        if (initialized) {
            return;
        }
        
        this.context = context.getApplicationContext();
        detectNativeAbis();
        setupDirectories();
        extractQemuBinaries();
        extractRuntimeLibraries();
        initialized = true;
        
        Log.i(TAG, "QEMU Manager initialized. Native ABIs: " + nativeSupportedAbis);
    }
    
    /**
     * Detect which ABIs are natively supported by the device
     */
    private void detectNativeAbis() {
        nativeSupportedAbis.clear();
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            // API 21+ provides SUPPORTED_ABIS
            String[] supportedAbis = Build.SUPPORTED_ABIS;
            for (String abi : supportedAbis) {
                if (abi.equals(ABI_ARM64) || abi.equals(ABI_ARM32) || abi.equals(ABI_X86_64)) {
                    nativeSupportedAbis.add(abi);
                }
            }
        } else {
            // Fallback for older APIs
            String primaryAbi = Build.CPU_ABI;
            if (primaryAbi.equals(ABI_ARM64) || primaryAbi.equals(ABI_ARM32) || primaryAbi.equals(ABI_X86_64)) {
                nativeSupportedAbis.add(primaryAbi);
            }
            
            String secondaryAbi = Build.CPU_ABI2;
            if (secondaryAbi != null && !secondaryAbi.isEmpty()) {
                if (secondaryAbi.equals(ABI_ARM64) || secondaryAbi.equals(ABI_ARM32) || secondaryAbi.equals(ABI_X86_64)) {
                    nativeSupportedAbis.add(secondaryAbi);
                }
            }
        }
        
        Log.d(TAG, "Detected native ABIs: " + nativeSupportedAbis);
    }
    
    /**
     * Setup directories for QEMU and runtime files
     */
    private void setupDirectories() {
        File filesDir = context.getFilesDir();
        qemuBaseDir = new File(filesDir, "qemu");
        runtimeBaseDir = new File(filesDir, "runtime");
        
        if (!qemuBaseDir.exists()) {
            qemuBaseDir.mkdirs();
        }
        if (!runtimeBaseDir.exists()) {
            runtimeBaseDir.mkdirs();
        }
    }
    
    /**
     * Extract QEMU binaries from assets
     */
    private void extractQemuBinaries() {
        // Extract QEMU binaries for architectures we need to emulate
        for (String abi : getEmulatedAbis()) {
            extractQemuForAbi(abi);
        }
    }
    
    /**
     * Extract QEMU binary for specific ABI
     */
    private void extractQemuForAbi(String abi) {
        try {
            String qemuBinaryName = getQemuBinaryName(abi);
            String assetPath = "qemu/" + getHostAbi() + "/" + qemuBinaryName;
            File targetFile = new File(qemuBaseDir, qemuBinaryName);
            
            // Only extract if file doesn't exist or is outdated
            if (!targetFile.exists()) {
                Log.d(TAG, "Extracting QEMU binary: " + assetPath);
                extractAsset(assetPath, targetFile);
                // Make executable
                targetFile.setExecutable(true, false);
                Log.i(TAG, "QEMU binary extracted and marked executable: " + targetFile.getAbsolutePath());
            }
        } catch (Exception e) {
            Log.w(TAG, "Could not extract QEMU binary for " + abi + ": " + e.getMessage());
        }
    }
    
    /**
     * Extract Android runtime libraries from assets
     */
    private void extractRuntimeLibraries() {
        for (String abi : getEmulatedAbis()) {
            extractRuntimeForAbi(abi);
        }
    }
    
    /**
     * Extract runtime libraries for specific ABI
     */
    private void extractRuntimeForAbi(String abi) {
        try {
            String[] runtimeFiles = {"linker64", "linker", "libc.so", "libm.so", "libdl.so"};
            File abiDir = new File(runtimeBaseDir, abi);
            if (!abiDir.exists()) {
                abiDir.mkdirs();
            }
            
            for (String filename : runtimeFiles) {
                String assetPath = "runtime/" + abi + "/" + filename;
                File targetFile = new File(abiDir, filename);
                
                if (!targetFile.exists()) {
                    try {
                        extractAsset(assetPath, targetFile);
                        targetFile.setExecutable(true, false);
                        Log.d(TAG, "Extracted runtime file: " + filename + " for " + abi);
                    } catch (Exception e) {
                        Log.d(TAG, "Runtime file not available: " + assetPath);
                    }
                }
            }
        } catch (Exception e) {
            Log.w(TAG, "Could not extract runtime for " + abi + ": " + e.getMessage());
        }
    }
    
    /**
     * Extract a single asset file to target location
     */
    private void extractAsset(String assetPath, File targetFile) throws Exception {
        InputStream is = context.getAssets().open(assetPath);
        FileOutputStream fos = new FileOutputStream(targetFile);
        
        byte[] buffer = new byte[8192];
        int length;
        while ((length = is.read(buffer)) > 0) {
            fos.write(buffer, 0, length);
        }
        
        fos.flush();
        fos.close();
        is.close();
    }
    
    /**
     * Check if an ABI needs QEMU emulation
     */
    public boolean needsQemu(String abi) {
        if (!initialized) {
            Log.w(TAG, "QemuManager not initialized, assuming no QEMU needed");
            return false;
        }
        return !nativeSupportedAbis.contains(abi);
    }
    
    /**
     * Get the set of ABIs that need to be emulated
     */
    public Set<String> getEmulatedAbis() {
        Set<String> emulated = new HashSet<>();
        Set<String> allAbis = new HashSet<>(Arrays.asList(ABI_ARM64, ABI_ARM32, ABI_X86_64));
        
        for (String abi : allAbis) {
            if (!nativeSupportedAbis.contains(abi)) {
                emulated.add(abi);
            }
        }
        
        return emulated;
    }
    
    /**
     * Get the primary host ABI
     */
    public String getHostAbi() {
        if (nativeSupportedAbis.contains(ABI_ARM64)) {
            return ABI_ARM64;
        } else if (nativeSupportedAbis.contains(ABI_X86_64)) {
            return ABI_X86_64;
        } else if (nativeSupportedAbis.contains(ABI_ARM32)) {
            return ABI_ARM32;
        }
        return Build.CPU_ABI;
    }
    
    /**
     * Get QEMU binary name for target ABI
     */
    private String getQemuBinaryName(String targetAbi) {
        switch (targetAbi) {
            case ABI_ARM64:
                return "qemu-aarch64-static";
            case ABI_ARM32:
                return "qemu-arm-static";
            case ABI_X86_64:
                return "qemu-x86_64-static";
            default:
                return "qemu-" + targetAbi + "-static";
        }
    }
    
    /**
     * Get QEMU binary file for target ABI
     */
    public File getQemuBinary(String targetAbi) {
        String binaryName = getQemuBinaryName(targetAbi);
        return new File(qemuBaseDir, binaryName);
    }
    
    /**
     * Get runtime directory for target ABI
     */
    public File getRuntimeDir(String targetAbi) {
        return new File(runtimeBaseDir, targetAbi);
    }
    
    /**
     * Get linker path for target ABI
     */
    public String getLinkerPath(String targetAbi) {
        File runtimeDir = getRuntimeDir(targetAbi);
        // Try linker64 first for 64-bit architectures
        if (targetAbi.equals(ABI_ARM64) || targetAbi.equals(ABI_X86_64)) {
            File linker64 = new File(runtimeDir, "linker64");
            if (linker64.exists()) {
                return linker64.getAbsolutePath();
            }
        }
        // Fallback to linker
        File linker = new File(runtimeDir, "linker");
        if (linker.exists()) {
            return linker.getAbsolutePath();
        }
        return null;
    }
    
    /**
     * Check if QEMU is available for target ABI
     */
    public boolean isQemuAvailable(String targetAbi) {
        if (nativeSupportedAbis.contains(targetAbi)) {
            return true; // Native support, no QEMU needed
        }
        
        File qemuBinary = getQemuBinary(targetAbi);
        return qemuBinary.exists() && qemuBinary.canExecute();
    }
    
    /**
     * Get native supported ABIs
     */
    public Set<String> getNativeSupportedAbis() {
        return new HashSet<>(nativeSupportedAbis);
    }
    
    /**
     * Check if manager is initialized
     */
    public boolean isInitialized() {
        return initialized;
    }
}
